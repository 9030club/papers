<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deep Reinforcement Learning: Pong from Pixels - RYO Analysis</title>
    <link rel="stylesheet" href="../../assets/style.css">
</head>
<body>
    <!-- Desktop Header -->
    <header class="desktop-header">
        <div class="header-left">
            <h1><a href="../../index.html">9030club</a> / Deep Reinforcement Learning: Pong from Pixels</h1>
            <div class="filename-subtitle">karpathy_rl.pdf</div>
        </div>
        <div class="header-right">
            <div class="mode-toggle">
                <button class="mode-btn active" data-mode="markdown">markdown</button>
                <button class="mode-btn" data-mode="pdf">pdf</button>
                <button class="qr-btn" id="qr-btn" title="Show QR Code">
                    <img src="../../assets/qr-code-icon.png" alt="QR Code" style="width: 16px; height: 16px;">
                </button>
            </div>
        </div>
    </header>
    
    <!-- Desktop 4-Column Layout -->
    <main class="four-column-layout">
        <section class="questions-column">
            <ul class="question-list">
                <li><button class="question-btn" data-question="1">1. What were they trying to do?</button></li>
<li><button class="question-btn" data-question="2">2. Why does it matter?</button></li>
<li><button class="question-btn" data-question="3">3. What did they try?</button></li>
<li><button class="question-btn" data-question="4">4. Did it work?</button></li>
<li><button class="question-btn" data-question="5">5. What did they compare it to?</button></li>
<li><button class="question-btn" data-question="6">6. What was it tested on?</button></li>
<li><button class="question-btn" data-question="7">7. What's cool about it?</button></li>
<li><button class="question-btn" data-question="8">8. What's sketchy about it?</button></li>
<li><button class="question-btn" data-question="9">9. Can anyone use this?</button></li>
<li><button class="question-btn" data-question="10">10. What's still left to figure out?</button></li>

            </ul>
        </section>
        
        <section class="answers-column">
            <div class="answer-content">
                <p class="placeholder">Click a question to see the answer</p>
            </div>
        </section>
        
        <section class="page-column">
            <div class="page-content">
                <h3>Deep Reinforcement Learning: Pong from Pixels</h3>
<p><h1>Deep Reinforcement Learning: Pong from Pixels</h1></p><p>This is a long overdue blog post on Reinforcement Learning (RL). RL is hot! You may have noticed that computers can now automatically learn to play ATARI games (from raw game pixels!), they are beating world champions at Go, simulated quadrupeds are learning to run and leap, and robots are learning how to perform complex manipulation tasks that defy explicit programming. It turns out that all of these advances fall under the umbrella of RL research. I also became interested in RL myself over the last year: I worked through Richard Sutton's book, read through David Silver's course, watched John Schulmann's lectures, wrote an RL library in Javascript, over the summer interned at DeepMind working in the DeepRL group, and most recently pitched in a little with the design/development of OpenAI Gym, a new RL benchmarking toolkit. So l've certainly been on this funwagon for at least a year but until now I haven't gotten around to writing up a short post on why RL is a big deal, what it's about, how it all developed and where it might be going.
![img-0.jpeg](img-0.jpeg)</p><p>Examples of RL in the wild. From left to right: Deep Q Learning network playing ATARI, AlphaGo, Berkeley robot stacking Legos, physically-simulated quadruped leaping over terrain.</p><p>It's interesting to reflect on the nature of recent progress in RL. I broadly like to think about four separate factors that hold back AI:</p><p><h2>1. Compute (the obvious one: Moore's Law, GPUs, ASICs),</h2>
<h2>2. Data (in a nice form, not just out there somewhere on the internet - e.g. ImageNet),</h2>
<h2>3. Algorithms (research and ideas, e.g. backprop, CNN, LSTM), and</h2>
<h2>4. Infrastructure (software under you - Linux, TCP/IP, Git, ROS, PR2, AWS, AMT, TensorFlow, etc.).</h2></p><p>Similar to what happened in Computer Vision, the progress in RL is not driven as much as you might reasonably assume by new amazing ideas. In Computer Vision, the 2012 AlexNet was mostly a scaled up (deeper and wider) version of 1990's ConvNets. Similarly, the ATARI Deep Q Learning paper from 2013 is an implementation of a standard algorithm (Q Learning with function approximation, which you can find in the standard RL book of Sutton 1998), where the function approximator happened to be a ConvNet. AlphaGo uses policy gradients with Monte Carlo Tree Search (MCTS) - these are also standard components. Of course, it takes a lot of skill and patience to get it to work, and multiple clever tweaks on</p><p>top of old algorithms have been developed, but to a first-order approximation the main driver of recent progress is not the algorithms but (similar to Computer Vision) compute/data/infrastructure.</p><p>Now back to RL. Whenever there is a disconnect between how magical something seems and how simple it is under the hood I get all antsy and really want to write a blog post. In this case l've seen many people who can't believe that we can automatically learn to play most ATARI games at human level, with one algorithm, from pixels, and from scratch - and it is amazing, and l've been there myself! But at the core the approach we use is also really quite profoundly dumb (though I understand it's easy to make such claims in retrospect). Anyway, l'd like to walk you through Policy Gradients (PG), our favorite default choice for attacking RL problems at the moment. If you're from outside of RL you might be curious why I'm not presenting DQN instead, which is an alternative and better-known RL algorithm, widely popularized by the ATARI game playing paper. It turns out that Q-Learning is not a great algorithm (you could say that DQN is so 2013 (okay l'm 50\% joking)). In fact most people prefer to use Policy Gradients, including the authors of the original DQN paper who have shown Policy Gradients to work better than Q Learning when tuned well. PG is preferred because it is end-to-end: there's an explicit policy and a principled approach that directly optimizes the expected reward. Anyway, as a running example we'll learn to play an ATARI game (Pong!) with PG, from scratch, from pixels, with a deep neural network, and the whole thing is 130 lines of Python only using numpy as a dependency (Gist link). Lets get to it.</p>
            </div>
        </section>
        
        <section class="thumbnails-column">
            <ul class="thumbnail-list">
                <li><button class="thumbnail-btn" data-page="1">1. Deep Reinforcement Learning: Pong from Pixels</button></li>
<li><button class="thumbnail-btn" data-page="2">2. Pong from pixels</button></li>
<li><button class="thumbnail-btn" data-page="3">3. What isn't happening</button></li>
<li><button class="thumbnail-btn" data-page="4">4. Non-differentiable computation in Neural Networks</button></li>
<li><button class="thumbnail-btn" data-page="5">5. Conclusions</button></li>
<li><button class="thumbnail-btn" data-page="6">6. Join the discussion...</button></li>
<li><button class="thumbnail-btn" data-page="7">7. ISO provider</button></li>

            </ul>
        </section>
    </main>
    
    <!-- Mobile Layout -->
    <div class="mobile-layout">
        <!-- Mobile Header -->
        <header class="mobile-header">
            <div class="mobile-title">
                <h1><a href="../../index.html">9030club</a></h1>
                <div class="mobile-paper-title">Deep Reinforcement Learning: Pong from Pixels</div>
                <div class="mobile-filename">karpathy_rl.pdf</div>
            </div>
            <button class="mobile-qr-btn" id="mobile-qr-btn" title="Show QR Code">
                <img src="../../assets/qr-code-icon.png" alt="QR Code" style="width: 20px; height: 20px;">
            </button>
        </header>
        
        <!-- Mobile Navigation Container -->
        <div class="mobile-nav-container">
            <!-- Mobile Tab Navigation -->
            <div class="mobile-tabs">
                <button class="mobile-tab-btn active" data-tab="qa">QA</button>
                <button class="mobile-tab-btn" data-tab="pdf">PDF</button>
                <button class="mobile-tab-btn" data-tab="markdown">Markdown</button>
            </div>
            
            <!-- Mobile Navigation Bar -->
            <div class="mobile-nav" id="mobile-nav">
                <button class="mobile-nav-btn" id="mobile-prev-btn">‹</button>
                <div class="mobile-nav-info" id="mobile-nav-info">Q1 of 10</div>
                <button class="mobile-nav-btn" id="mobile-next-btn">›</button>
            </div>
        </div>
        
        <!-- Mobile Content Area -->
        <div class="mobile-content" id="mobile-content">
            <div class="mobile-content-inner">
                <p class="mobile-placeholder">Loading content...</p>
            </div>
        </div>
    </div>
    
    <!-- QR Code Overlay -->
    <div class="qr-overlay" id="qr-overlay">
        <img src="qr-code.png" alt="QR Code" id="qr-image">
    </div>
    
    <script src="../../assets/app.js"></script>
    <script>
        // Initialize with paper data
        window.paperData = {"title": "Deep Reinforcement Learning: Pong from Pixels", "slug": "karpathyrl", "questions": {"1": {"question": "What were they trying to do?", "answer": "The main goal of the paper \"Deep Reinforcement Learning: Pong from Pixels\" was to explore and demonstrate the application of policy gradients in reinforcement learning by training an AI agent to play the game Pong from raw pixel data. The big picture objective was to illustrate how reinforcement learning can be used to develop AI systems capable of learning complex tasks from scratch, highlighting the potential and limitations of current algorithms compared to human learning processes.", "timestamp": "2025-08-18 11:58:32"}, "2": {"question": "Why does it matter?", "answer": "The paper on deep reinforcement learning (RL) matters because it demonstrates the capability of RL algorithms, specifically Policy Gradients, to learn complex tasks like playing ATARI games from raw pixels. This is significant because it shows how RL can handle high-dimensional input spaces without explicit programming, which is crucial for advancing AI in areas like robotics and autonomous systems. On a broader level, it highlights the potential of RL to solve real-world problems by learning optimal strategies through trial and error, a method that could be applied to various domains beyond gaming. Ultimately, this research contributes to the ongoing effort to develop AI systems that can autonomously learn and adapt to complex environments, which is a key step towards achieving more general forms of artificial intelligence.", "timestamp": "2025-08-18 11:58:36"}, "3": {"question": "What did they try?", "answer": "In the paper \"Deep Reinforcement Learning: Pong from Pixels,\" the authors used Policy Gradients (PG) to train an AI agent to play the game Pong from raw pixel data. Their approach involved defining a policy network using a 2-layer neural network that takes image frames as input and outputs the probability of moving the paddle up. The network learns by sampling actions and adjusting its parameters based on the rewards received, encouraging actions that lead to positive outcomes and discouraging those that do not. This method allows the agent to learn effective strategies through trial and error, despite the complexity of the credit assignment problem in reinforcement learning.", "timestamp": "2025-08-18 11:58:43"}, "4": {"question": "Did it work?", "answer": "Yes, the idea worked. The paper describes the successful implementation of a policy gradient method to train an agent to play the game of Pong from raw pixels. The trained agent was able to perform slightly better than the AI opponent after approximately 200,000 games, demonstrating the effectiveness of the reinforcement learning approach, although the process required significant computational resources and time.", "timestamp": "2025-08-18 11:58:47"}, "5": {"question": "What did they compare it to?", "answer": "In the paper, the authors compared their approach of using Policy Gradients (PG) to the Deep Q-Learning (DQN) algorithm, which was popularized by the ATARI game playing paper. They argue that PG is preferred over DQN because it is end-to-end and directly optimizes the expected reward, whereas DQN is not considered a great algorithm by the authors. The original DQN paper's authors also found that PG works better than Q-Learning when properly tuned. The benchmark used for comparison was the performance of the AI in playing the ATARI game Pong.", "timestamp": "2025-08-18 11:58:52"}, "6": {"question": "What was it tested on?", "answer": "The paper tested the deep reinforcement learning approach on the ATARI game Pong. The evaluation setup involved training a policy network using Policy Gradients to learn to play Pong from raw pixel data. The network was trained over approximately 8,000 episodes, which equates to roughly 200,000 games, using a 2-layer neural network with 200 hidden units. The training process involved playing batches of 10 episodes, with the policy being updated based on the outcomes of these games.", "timestamp": "2025-08-18 11:59:00"}, "7": {"question": "What's cool about it?", "answer": "The paper's approach is interesting because it demonstrates the power of policy gradients in reinforcement learning by training an agent to play Pong from raw pixels using a simple, end-to-end method. The novelty lies in its minimalistic implementation—achieving this in just 130 lines of Python code—and the use of a straightforward policy network with a stochastic policy, which allows for learning from scratch without prior knowledge. The method's elegance is in its ability to learn complex behaviors through a process akin to trial and error, highlighting both the potential and limitations of current RL techniques compared to human learning.", "timestamp": "2025-08-18 11:59:06"}, "8": {"question": "What's sketchy about it?", "answer": "The paper highlights several limitations and concerns with the current state of deep reinforcement learning (RL). One major red flag is the reliance on brute-force search, where the algorithm must randomly stumble upon rewarding situations, which is inefficient and not scalable to complex real-world problems. Additionally, the approach lacks the ability to build abstract, rich models of the environment, unlike humans who can quickly understand and plan within a game. The paper also notes that the training process is resource-intensive, requiring a large number of samples and significant computational power, which can be a barrier to practical applications.", "timestamp": "2025-08-18 11:59:12"}, "9": {"question": "Can anyone use this?", "answer": "The deep reinforcement learning approach described in the paper is theoretically accessible to anyone with programming knowledge, as it involves implementing a 130-line Python script using basic libraries like numpy. However, it can be complex to execute effectively due to the need for significant computational resources (ideally GPUs) and expertise in tuning hyperparameters. While the method is not prohibitively expensive in terms of software, the practical application may be limited by the computational demands and the time required for training, making it less accessible for those without adequate resources or technical expertise.", "timestamp": "2025-08-18 11:59:18"}, "10": {"question": "What's still left to figure out?", "answer": "The paper highlights several unsolved challenges and future directions in reinforcement learning (RL). It points out that current RL algorithms, like Policy Gradients, lack the ability to build abstract, rich representations for rapid learning, unlike humans. The paper suggests that future research should focus on developing algorithms that can understand and plan within complex environments, akin to human cognitive processes. Additionally, the paper notes the difficulty of applying RL in real-world settings due to the need for extensive exploration, and it mentions ongoing research in improving exploration strategies and integrating additional supervision to mitigate these challenges.", "timestamp": "2025-08-18 11:59:27"}}, "markdown_pages": [{"id": 1, "title": "Deep Reinforcement Learning: Pong from Pixels", "content": "# Deep Reinforcement Learning: Pong from Pixels\n\nThis is a long overdue blog post on Reinforcement Learning (RL). RL is hot! You may have noticed that computers can now automatically learn to play ATARI games (from raw game pixels!), they are beating world champions at Go, simulated quadrupeds are learning to run and leap, and robots are learning how to perform complex manipulation tasks that defy explicit programming. It turns out that all of these advances fall under the umbrella of RL research. I also became interested in RL myself over the last year: I worked through Richard Sutton's book, read through David Silver's course, watched John Schulmann's lectures, wrote an RL library in Javascript, over the summer interned at DeepMind working in the DeepRL group, and most recently pitched in a little with the design/development of OpenAI Gym, a new RL benchmarking toolkit. So l've certainly been on this funwagon for at least a year but until now I haven't gotten around to writing up a short post on why RL is a big deal, what it's about, how it all developed and where it might be going.\n![img-0.jpeg](img-0.jpeg)\n\nExamples of RL in the wild. From left to right: Deep Q Learning network playing ATARI, AlphaGo, Berkeley robot stacking Legos, physically-simulated quadruped leaping over terrain.\n\nIt's interesting to reflect on the nature of recent progress in RL. I broadly like to think about four separate factors that hold back AI:\n\n## 1. Compute (the obvious one: Moore's Law, GPUs, ASICs),\n## 2. Data (in a nice form, not just out there somewhere on the internet - e.g. ImageNet),\n## 3. Algorithms (research and ideas, e.g. backprop, CNN, LSTM), and\n## 4. Infrastructure (software under you - Linux, TCP/IP, Git, ROS, PR2, AWS, AMT, TensorFlow, etc.).\n\nSimilar to what happened in Computer Vision, the progress in RL is not driven as much as you might reasonably assume by new amazing ideas. In Computer Vision, the 2012 AlexNet was mostly a scaled up (deeper and wider) version of 1990's ConvNets. Similarly, the ATARI Deep Q Learning paper from 2013 is an implementation of a standard algorithm (Q Learning with function approximation, which you can find in the standard RL book of Sutton 1998), where the function approximator happened to be a ConvNet. AlphaGo uses policy gradients with Monte Carlo Tree Search (MCTS) - these are also standard components. Of course, it takes a lot of skill and patience to get it to work, and multiple clever tweaks on\n\ntop of old algorithms have been developed, but to a first-order approximation the main driver of recent progress is not the algorithms but (similar to Computer Vision) compute/data/infrastructure.\n\nNow back to RL. Whenever there is a disconnect between how magical something seems and how simple it is under the hood I get all antsy and really want to write a blog post. In this case l've seen many people who can't believe that we can automatically learn to play most ATARI games at human level, with one algorithm, from pixels, and from scratch - and it is amazing, and l've been there myself! But at the core the approach we use is also really quite profoundly dumb (though I understand it's easy to make such claims in retrospect). Anyway, l'd like to walk you through Policy Gradients (PG), our favorite default choice for attacking RL problems at the moment. If you're from outside of RL you might be curious why I'm not presenting DQN instead, which is an alternative and better-known RL algorithm, widely popularized by the ATARI game playing paper. It turns out that Q-Learning is not a great algorithm (you could say that DQN is so 2013 (okay l'm 50\\% joking)). In fact most people prefer to use Policy Gradients, including the authors of the original DQN paper who have shown Policy Gradients to work better than Q Learning when tuned well. PG is preferred because it is end-to-end: there's an explicit policy and a principled approach that directly optimizes the expected reward. Anyway, as a running example we'll learn to play an ATARI game (Pong!) with PG, from scratch, from pixels, with a deep neural network, and the whole thing is 130 lines of Python only using numpy as a dependency (Gist link). Lets get to it."}, {"id": 2, "title": "Pong from pixels", "content": "# Pong from pixels\n\n![img-1.jpeg](img-1.jpeg)\n\nLeft: The game of Pong. Right: Pong is a special case of a Markov Decision Process (MDP): A graph where each node is a particular game state and each edge is a possible (in general probabilistic) transition. Each edge also gives a reward, and the goal is to compute the optimal way of acting in any state to maximize rewards.\n\nThe game of Pong is an excellent example of a simple RL task. In the ATARI 2600 version we'll use you play as one of the paddles (the other is controlled by a decent Al ) and you have to bounce the ball past the other player (I don't really have to explain Pong, right?). On the low level the game works as follows: we receive an image frame (a $210 \\times 160 \\times 3$ byte array (integers from 0 to 255 giving pixel values)) and we get to decide if we want to move the paddle UP or DOWN (i.e. a binary choice). After every single choice the game simulator executes the action and gives us a reward: Either a +1 reward if the ball went past the opponent, a -1 reward if we missed the ball, or 0 otherwise. And of course, our goal is to move the paddle so that we get lots of reward.\n\nAs we go through the solution keep in mind that we'll try to make very few assumptions about Pong because we secretly don't really care about Pong; We care about complex, high-dimensional problems like robot manipulation, assembly and navigation. Pong is just a fun toy test case, something we play with while we figure out how to write very general Al systems that can one day do arbitrary useful tasks.\n\nPolicy network. First, we're going to define a policy network that implements our player (or \"agent\"). This network will take the state of the game and decide what we should do (move UP or DOWN). As our favorite simple block of compute we'll use a 2-layer neural network that takes the raw image pixels (100,800 numbers total ( $\\left.210^{*} 160^{*} 3\\right)$ ), and produces a single number indicating the probability of going UP. Note that it is standard to use a stochastic policy, meaning that we only produce a probability of moving UP. Every iteration we will sample from this distribution (i.e. toss a biased coin) to get the actual move. The reason for this will become more clear once we talk about training.\n![img-2.jpeg](img-2.jpeg)\n\nOur policy network is a 2-layer fully-connected net.\nand to make things concrete here is how you might implement this policy network in Python/numpy. Suppose we're given a vector $x$ that holds the (preprocessed) pixel information. We would compute:\n\n```\nh = np.dot(W1, x) # compute hidden layer neuron activations\nh[h<0] = 0 # ReLU nonlinearity: threshold at zero\nlogp = np.dot(W2, h) # compute log probability of going up\np = 1.0 / (1.0 + np.exp(-logp)) # sigmoid function (gives probability of going up)\n```\n\nwhere in this snippet W1 and W2 are two matrices that we initialize randomly. We're not using biases because meh. Notice that we use the sigmoid non-linearity at the end, which squashes the output probability to the range $[0,1]$. Intuitively, the neurons in the hidden layer (which have their weights arranged along the rows of W1 ) can detect various game scenarios (e.g. the ball is in the top, and our paddle is in the middle), and the weights in W2 can then decide if in each case we should be going UP or DOWN. Now, the initial random W1 and W2 will of course cause the player to spasm on spot. So the only problem now is to find W1 and W2 that lead to expert play of Pong!\n\nFine print: preprocessing. Ideally you'd want to feed at least 2 frames to the policy network so that it can detect motion. To make things a bit simpler (I did these experiments on my Macbook) I'll do a tiny bit of preprocessing, e.g. we'll actually feed difference frames to the network (i.e. subtraction of current and last frame).\n\nIt sounds kind of impossible. At this point l'd like you to appreciate just how difficult the RL problem is. We get 100,800 numbers $\\left(210^{*} 160^{*} 3\\right)$ and forward our policy network (which easily involves on order of a million parameters in W1 and W2 ). Suppose that we decide to go UP. The game might respond that we get 0 reward this time step and gives us another 100,800 numbers for the next frame. We could repeat this process for hundred timesteps before we get any non-zero reward! E.g. suppose we finally get a +1 . That's great, but how can we tell what made that happen? Was it something we did just now? Or maybe 76 frames ago? Or maybe it had something to do with frame 10 and then frame 90 ? And how do we figure out which of the million knobs to change and how, in order to do better in the future? We call this the credit assignment problem. In the specific case of Pong we know that we get a +1 if the ball makes it past the opponent. The true cause is that we happened to bounce the ball on a good trajectory, but in fact we did so many frames ago - e.g. maybe about 20 in case of Pong, and every single action we did afterwards had zero effect on whether or not we end up getting the reward. In other words we're faced with a very difficult problem and things are looking quite bleak.\n\nSupervised Learning. Before we dive into the Policy Gradients solution l'd like to remind you briefly about supervised learning because, as we'll see, RL is very similar. Refer to the diagram below. In ordinary supervised learning we would feed an image to the network and get some probabilities, e.g. for two classes UP and DOWN. I'm showing log probabilities ( $-1.2,-0.36$ ) for UP and DOWN instead of the raw probabilities ( $30 \\%$ and $70 \\%$ in this case) because we always optimize the log probability of the correct label (this makes math nicer, and is equivalent to optimizing the raw probability because log is monotonic). Now, in supervised learning we would have access to a label. For example, we might be told that the correct thing to do right now is to go UP (label 0). In an implementation we would enter gradient of 1.0 on the log probability of UP and run backprop to compute the gradient vector $\\nabla_{W} \\log p(y=U P \\mid x)$. This gradient would tell us how we should change every one of our million parameters to make the network slightly more likely to predict UP. For example, one of the million parameters in the network might have a gradient of -2.1 , which means that if we were to increase that parameter by a small positive amount (e.g. 0.001 ), the log probability of UP would decrease by $2.1 * 0.001$ (decrease due to the negative sign). If we then did a parameter update then, yay, our network would now be slightly more likely to predict UP when it sees a very similar image in the future.\n![img-3.jpeg](img-3.jpeg)\n\nPolicy Gradients. Okay, but what do we do if we do not have the correct label in the Reinforcement Learning setting? Here is the Policy Gradients solution (again refer to diagram below). Our policy network calculated probability of going UP as $30 \\%$ (logprob -1.2) and DOWN as $70 \\%$ (logprob -0.36). We will now sample an action from this distribution; E.g. suppose we sample DOWN, and we will execute it in the game. At this point notice one interesting fact: We could immediately fill in a gradient of 1.0 for DOWN as\n\nwe did in supervised learning, and find the gradient vector that would encourage the network to be slightly more likely to do the DOWN action in the future. So we can immediately evaluate this gradient and that's great, but the problem is that at least for now we do not yet know if going DOWN is good. But the critical point is that that's okay, because we can simply wait a bit and see! For example in Pong we could wait until the end of the game, then take the reward we get (either +1 if we won or -1 if we lost), and enter that scalar as the gradient for the action we have taken (DOWN in this case). In the example below, going DOWN ended up to us losing the game ( -1 reward). So if we fill in -1 for log probability of DOWN and do backprop we will find a gradient that discourages the network to take the DOWN action for that input in the future (and rightly so, since taking that action led to us losing the game).\n![img-4.jpeg](img-4.jpeg)\n\nAnd that's it: we have a stochastic policy that samples actions and then actions that happen to eventually lead to good outcomes get encouraged in the future, and actions taken that lead to bad outcomes get discouraged. Also, the reward does not even need to be +1 or -1 if we win the game eventually. It can be an arbitrary measure of some kind of eventual quality. For example if things turn out really well it could be 10.0, which we would then enter as the gradient instead of -1 to start off backprop. That's the beauty of neural nets; Using them can feel like cheating: You're allowed to have 1 million parameters embedded in 1 teraflop of compute and you can make it do arbitrary things with SGD. It shouldn't work, but amusingly we live in a universe where it does.\n\nTraining protocol. So here is how the training will work in detail. We will initialize the policy network with some W1, W2 and play 100 games of Pong (we call these policy \"rollouts\"). Lets assume that each game is made up of 200 frames so in total we've made 20,000 decisions for going UP or DOWN and for each one of these we know the parameter gradient, which tells us how we should change the parameters if we wanted to encourage that decision in that state in the future. All that remains now is to label every decision we've made as good or bad. For example suppose we won 12 games and lost 88 . We'll take all $200^{*} 12=$ 2400 decisions we made in the winning games and do a positive update (filling in a +1.0 in the gradient for the sampled action, doing backprop, and parameter update encouraging the actions we picked in all those states). And we'll take the other $200^{*} 88=17600$ decisions we made in the losing games and do a negative update (discouraging whatever we did). And... that's it. The network will now become slightly more likely to repeat actions that worked, and slightly less likely to repeat actions that didn't work. Now we play another 100 games with our new, slightly improved policy and rinse and repeat.\n\nPolicy Gradients: Run a policy for a while. See what actions led to high rewards. Increase their probability.\n\n![img-5.jpeg](img-5.jpeg)\n\nCartoon diagram of 4 games. Each black circle is some game state (three example states are visualized on the bottom), and each arrow is a transition, annotated with the action that was sampled. In this case we won 2 games and lost 2 games. With Policy Gradients we would take the two games we won and slightly encourage every single action we made in that episode. Conversely, we would also take the two games we lost and slightly discourage every single action we made in that episode.\n\nIf you think through this process you'll start to find a few funny properties. For example what if we made a good action in frame 50 (bouncing the ball back correctly), but then missed the ball in frame 150? If every single action is now labeled as bad (because we lost), wouldn't that discourage the correct bounce on frame 50? You're right - it would. However, when you consider the process over thousands/millions of games, then doing the first bounce correctly makes you slightly more likely to win down the road, so on average you'll see more positive than negative updates for the correct bounce and your policy will end up doing the right thing.\n\nUpdate: December 9, 2016 - alternative view. In my explanation above I use the terms such as \"fill in the gradient and backprop\", which I realize is a special kind of thinking if you're used to writing your own backprop code, or using Torch where the gradients are explicit and open for tinkering. However, if you're used to Theano or TensorFlow you might be a little perplexed because the code is oranized around specifying a loss function and the backprop is fully automatic and hard to tinker with. In this case, the following alternative view might be more intuitive. In vanilla supervised learning the objective is to maximize $\\sum_{i} \\log p\\left(y_{i} \\mid x_{i}\\right)$ where $x_{i}, y_{i}$ are training examples (such as images and their labels). Policy gradients is exactly the same as supervised learning with two minor differences: 1) We don't have the correct labels $y_{i}$ so as a \"fake label\" we substitute the action we happened to sample from the policy when it saw $x_{i}$, and 2) We modulate the loss for each example multiplicatively based on the eventual outcome, since we want to increase the log probability for actions that worked and decrease it for those that didn't. So in summary our loss now looks like $\\sum_{i} A_{i} \\log p\\left(y_{i} \\mid x_{i}\\right)$, where $y_{i}$ is the action we happened to sample and $A_{i}$ is a number that we call an advantage. In the case of Pong, for example, $A_{i}$ could be 1.0 if we eventually won in the episode that contained $x_{i}$ and -1.0 if we lost. This will ensure that we maximize the log probability of actions that led to good outcome and minimize the log probability of those that didn't. So reinforcement learning is exactly like supervised learning, but on a continuously changing dataset (the episodes), scaled by the advantage, and we only want to do one (or very few) updates based on each sampled dataset.\n\nMore general advantage functions. I also promised a bit more discussion of the returns. So far we have judged the goodness of every individual action based on whether or not we win the game. In a more general RL setting we would receive some reward $r_{t}$ at every time step. One common choice is to use a discounted reward, so the \"eventual reward\" in the diagram above would become $R_{t}=\\sum_{k=0}^{\\infty} \\gamma^{k} r_{t+k}$, where $\\gamma$ is a number between 0 and 1 called a discount factor (e.g. 0.99). The expression states that the strength with which we encourage a sampled action is the weighted sum of all rewards afterwards, but later rewards are exponentially less important. In practice it can can also be important to normalize these. For example, suppose we compute $R_{t}$ for all of the 20,000 actions in the batch of 100 Pong game rollouts above. One good idea is to \"standardize\" these returns (e.g. subtract mean, divide by standard deviation) before we plug them into backprop. This way we're always encouraging and discouraging roughly half of the performed actions. Mathematically you can also interpret these tricks as a way of controlling the variance of the policy gradient estimator. A more in-depth exploration can be found here.\n\nDeriving Policy Gradients. I'd like to also give a sketch of where Policy Gradients come from mathematically. Policy Gradients are a special case of a more general score function gradient estimator. The general case is that when we have an expression of the form $E_{x \\sim p(x \\mid \\theta)}[f(x)]$ - i.e. the expectation of some scalar valued score function $f(x)$ under some probability distribution $p(x ; \\theta)$ parameterized by some $\\theta$. Hint hint, $f(x)$ will become our reward function (or advantage function more generally) and $p(x)$ will be our policy network, which is really a model for $p(a \\mid I)$, giving a distribution over actions for any image $I$. Then we are interested in finding how we should shift the distribution (through its parameters $\\theta$ ) to increase the scores of its samples, as judged by $f$ (i.e. how do we change the network's parameters so that action samples get higher rewards). We have that:\n\n$$\n\\begin{aligned}\n\\nabla_{\\theta} E_{x}[f(x)] & =\\nabla_{\\theta} \\sum_{x} p(x) f(x) & & \\text { definition of expectation } \\\\\n& =\\sum_{x} \\nabla_{\\theta} p(x) f(x) & & \\text { swap sum and gradient } \\\\\n& =\\sum_{x} p(x) \\frac{\\nabla_{\\theta} p(x)}{p(x)} f(x) & & \\text { both multiply and divide by } p(x) \\\\\n& =\\sum_{x} p(x) \\nabla_{\\theta} \\log p(x) f(x) & & \\text { use the fact that } \\nabla_{\\theta} \\log (z)=\\frac{1}{z} \\nabla_{\\theta} z \\\\\n& =E_{x}\\left[f(x) \\nabla_{\\theta} \\log p(x)\\right] & & \\text { definition of expectation }\n\\end{aligned}\n$$\n\nTo put this in English, we have some distribution $p(x ; \\theta)$ (I used shorthand $p(x)$ to reduce clutter) that we can sample from (e.g. this could be a gaussian). For each sample we can also evaluate the score function $f$ which takes the sample and gives us some scalar-valued score. This equation is telling us how we should shift the distribution (through its parameters $\\theta$ ) if we wanted its samples to achieve higher scores, as judged by $f$. In particular, it says that look: draw some samples $x$, evaluate their scores $f(x)$, and for each $x$ also evaluate the second term $\\nabla_{\\theta} \\log p(x ; \\theta)$. What is this second term? It's a vector - the gradient that's giving us the direction in the parameter space that would lead to increase of the probability assigned to an $x$. In other words if we were to nudge $\\theta$ in the direction of $\\nabla_{\\theta} \\log p(x ; \\theta)$ we would see the new probability assigned to some $x$ slightly increase. If you look back at the formula, it's telling us that we should take this direction and multiply onto it the scalar-valued score $f(x)$. This will make it so that\n\nsamples that have a higher score will \"tug\" on the probability density stronger than the samples that have lower score, so if we were to do an update based on several samples from $p$ the probability density would shift around in the direction of higher scores, making highly-scoring samples more likely.\n![img-6.jpeg](img-6.jpeg)\n\nA visualization of the score function gradient estimator. Left: A gaussian distribution and a few samples from it (blue dots). On each blue dot we also plot the gradient of the log probability with respect to the gaussian's mean parameter. The arrow indicates the direction in which the mean of the distribution should be nudged to increase the probability of that sample. Middle: Overlay of some score function giving -1 everywhere except +1 in some small regions (note this can be an arbitrary and not necessarily differentiable scalar-valued function). The arrows are now color coded because due to the multiplication in the update we are going to average up all the green arrows, and the negative of the red arrows. Right: after parameter update, the green arrows and the reversed red arrows nudge us to left and towards the bottom. Samples from this distribution will now have a higher expected score, as desired.\n\nI hope the connection to RL is clear. Our policy network gives us samples of actions, and some of them work better than others (as judged by the advantage function). This little piece of math is telling us that the way to change the policy's parameters is to do some rollouts, take the gradient of the sampled actions, multiply it by the score and add everything, which is what we've done above. For a more thorough derivation and discussion I recommend John Schulman's lecture.\n\nLearning. Alright, we've developed the intuition for policy gradients and saw a sketch of their derivation. I implemented the whole approach in a 130-line Python script, which uses OpenAI Gym's ATARI 2600 Pong. I trained a 2-layer policy network with 200 hidden layer units using RMSProp on batches of 10 episodes (each episode is a few dozen games, because the games go up to score of 21 for either player). I did not tune the hyperparameters too much and ran the experiment on my (slow) Macbook, but after training for 3 nights I ended up with a policy that is slightly better than the AI player. The total number of episodes was approximately 8,000 so the algorithm played roughly 200,000 Pong games (quite a lot isn't it!) and made a total of $\\sim 800$ updates. I'm told by friends that if you train on GPU with ConvNets for a few days you can beat the AI player more often, and if you also optimize hyperparameters carefully you can also consistently dominate the AI player (i.e. win every single game). However, I didn't spend too much time computing or tweaking, so instead we end up with a Pong AI that illustrates the main ideas and works quite well:\n\n![img-7.jpeg](img-7.jpeg)\n\nThe learned agent (in green, right) facing off with the hard-coded Al opponent (left).\n\nLearned weights. We can also take a look at the learned weights. Due to preprocessing every one of our inputs is an $80 \\times 80$ difference image (current frame minus last frame). We can now take every row of W1, stretch them out to $80 \\times 80$ and visualize. Below is a collection of 40 (out of 200) neurons in a grid. White pixels are positive weights and black pixels are negative weights. Notice that several neurons are tuned to particular traces of bouncing ball, encoded with alternating black and white along the line. The ball can only be at a single spot, so these neurons are multitasking and will \"fire\" for multiple locations of the ball along that line. The alternating black and white is interesting because as the ball travels along the trace, the neuron's activity will fluctuate as a sine wave and due to the ReLU it would \"fire\" at discrete, separated positions along the trace. There's a bit of noise in the images, which I assume would have been mitigated if I used L2 regularization.\n![img-8.jpeg](img-8.jpeg)"}, {"id": 3, "title": "What isn't happening", "content": "# What isn't happening\n\nSo there you have it - we learned to play Pong from from raw pixels with Policy Gradients and it works quite well. The approach is a fancy form of guess-and-check, where the \"guess\" refers to sampling rollouts from our current policy, and the \"check\" refers to encouraging actions that lead to good outcomes. Modulo some details, this represents the state of the art in how we currently approach reinforcement learning problems. Its impressive that we can learn these behaviors, but if you understood the algorithm intuitively and you know how it works you should be at least a bit disappointed. In particular, how does it not work?\n\nCompare that to how a human might learn to play Pong. You show them the game and say something along the lines of \"You're in control of a paddle and you can move it up and down, and your task is to bounce the ball past the other player controlled by Al\", and you're set and ready to go. Notice some of the differences:\n\n- In practical settings we usually communicate the task in some manner (e.g. English above), but in a standard RL problem you assume an arbitrary reward function that you have to discover through environment interactions. It can be argued that if a human went into game of Pong but without knowing anything about the reward function (indeed, especially if the reward function was some static but random function), the human would have a lot of difficulty learning what to do but Policy Gradients would be indifferent, and likely work much better. Similarly, if we took the frames and permuted the pixels randomly then humans would likely fail, but our Policy Gradient solution could not even tell the difference (if it's using a fully connected network as done here).\n- A human brings in a huge amount of prior knowledge, such as intuitive physics (the ball bounces, it's unlikely to teleport, it's unlikely to suddenly stop, it maintains a constant velocity, etc.), and intuitive psychology (the Al opponent \"wants\" to win, is likely following an obvious strategy of moving towards the ball, etc.). You also understand the concept of being \"in control\" of a paddle, and that it responds to your UP/DOWN key commands. In contrast, our algorithms start from scratch which is simultaneously impressive (because it works) and depressing (because we lack concrete ideas for how not to).\n- Policy Gradients are a brute force solution, where the correct actions are eventually discovered and internalized into a policy. Humans build a rich, abstract model and plan within it. In Pong, I can reason that the opponent is quite slow so it might be a good strategy to bounce the ball with high vertical velocity, which would cause the opponent to not catch it in time. However, it also feels as though we also eventually \"internalize\" good solutions into what feels more like a reactive muscle memory policy. For example if you're learning a new motor task (e.g. driving a car with stick shift?) you often feel yourself thinking a lot in the beginning but eventually the task becomes automatic and mindless.\n- Policy Gradients have to actually experience a positive reward, and experience it very often in order to eventually and slowly shift the policy parameters towards repeating moves that give high rewards. With our abstract model, humans can figure out what is likely to give rewards without ever actually experiencing the rewarding or unrewarding transition. I don't have to actually experience crashing my car into a wall a few hundred times before I slowly start avoiding to do so.\n\n![img-9.jpeg](img-9.jpeg)\n\nLeft: Montezuma's Revenge: a difficult game for our RL algorithms. The player must jump down, climb up, get the key, and open the door. A human understands that acquiring a key is useful. The computer samples billions of random moves and $99 \\%$ of the time falls to its death or gets killed by the monster. In other words it's hard to \"stumble into\" the rewarding situation. Right: Another difficult game called Frostbite, where a human understands that things move, some things are good to touch, some things are bad to touch, and the goal is to build the igloo brick by brick. A good analysis of this game and a discussion of differences between the human and computer approach can be found in Building Machines That Learn and Think Like People.\n\nI'd like to also emphasize the point that, conversely, there are many games where Policy Gradients would quite easily defeat a human. In particular, anything with frequent reward signals that requires precise play, fast reflexes, and not too much long-term planning would be ideal, as these short-term correlations between rewards and actions can be easily \"noticed\" by the approach, and the execution meticulously perfected by the policy. You can see hints of this already happening in our Pong agent: it develops a strategy where it waits for the ball and then rapidly dashes to catch it just at the edge, which launches it quickly and with high vertical velocity. The agent scores several points in a row repeating this strategy. There are many ATARI games where Deep Q Learning destroys human baseline performance in this fashion - e.g. Pinball, Breakout, etc.\n\nIn conclusion, once you understand the \"trick\" by which these algorithms work you can reason through their strengths and weaknesses. In particular, we are nowhere near humans in building abstract, rich representations of games that we can plan within and use for rapid learning. One day a computer will look at an array of pixels and notice a key, a door, and think to itself that it is probably a good idea to pick up the\n\nkey and reach the door. For now there is nothing anywhere close to this, and trying to get there is an active area of research."}, {"id": 4, "title": "Non-differentiable computation in Neural Networks", "content": "# Non-differentiable computation in Neural Networks\n\nI'd like to mention one more interesting application of Policy Gradients unrelated to games: It allows us to design and train neural networks with components that perform (or interact with) non-differentiable computation. The idea was first introduced in Williams 1992 and more recently popularized by Recurrent Models of Visual Attention under the name \"hard attention\", in the context of a model that processed an image with a sequence of low-resolution foveal glances (inspired by our own human eyes). In particular, at every iteration an RNN would receive a small piece of the image and sample a location to look at next. For example the RNN might look at position $(5,30)$, receive a small piece of the image, then decide to look at $(24,50)$, etc. The problem with this idea is that there a piece of network that produces a distribution of where to look next and then samples from it. Unfortunately, this operation is non-differentiable because, intuitively, we don't know what would have happened if we sampled a different location. More generally, consider a neural network from some inputs to outputs:\n![img-10.jpeg](img-10.jpeg)\n\nNotice that most arrows (in blue) are differentiable as normal, but some of the representation transformations could optionally also include a non-differentiable sampling operation (in red). We can backprop through the blue arrows just fine, but the red arrow represents a dependency that we cannot backprop through.\n\nPolicy gradients to the rescue! We'll think about the part of the network that does the sampling as a small stochastic policy embedded in the wider network. Therefore, during training we will produce several samples (indicated by the branches below), and then we'll encourage samples that eventually led to good outcomes (in this case for example measured by the loss at the end). In other words we will train the parameters involved in the blue arrows with backprop as usual, but the parameters involved with the red arrow will now be updated independently of the backward pass using policy gradients, encouraging samples that led to low loss. This idea was also recently formalized nicely in Gradient Estimation Using Stochastic Computation Graphs.\n![img-11.jpeg](img-11.jpeg)\n\nTrainable Memory I/O. You'll also find this idea in many other papers. For example, a Neural Turing Machine has a memory tape that they it read and write from. To do a write operation one would like to execute something like $m[i]=x$, where $i$ and $x$ are predicted by an RNN controller network. However, this operation is non-differentiable because there is no signal telling us what would have happened to the loss if we were to write to a different location $j$ ! $=i$. Therefore, the NTM has to do soft read and write operations. It predicts an attention distribution a (with elements between 0 and 1 and summing to 1 , and peaky around the index we'd like to write to), and then doing for all i: m[i] = a[i]*x. This is now differentiable, but we have to pay a heavy computational price because we have to touch every single memory cell just to write to one position. Imagine if every assignment in our computers had to touch the entire RAM!\n\nHowever, we can use policy gradients to circumvent this problem (in theory), as done in RL-NTM. We still predict an attention distribution a, but instead of doing the soft write we sample locations to write to: i = sample(a); m[i] = x. During training we would do this for a small batch of i, and in the end make whatever branch worked best more likely. The large computational advantage is that we now only have to read/write at a single location at test time. However, as pointed out in the paper this strategy is very difficult to get working because one must accidentally stumble by working algorithms through sampling. The current consensus is that PG works well only in settings where there are a few discrete choices so that one is not hopelessly sampling through huge search spaces.\n\nHowever, with Policy Gradients and in cases where a lot of data/compute is available we can in principle dream big - for instance we can design neural networks that learn to interact with large, non-differentiable modules such as Latex compilers (e.g. if you'd like char-rnn to generate latex that compiles), or a SLAM system, or LQR solvers, or something. Or, for example, a superintelligence might want to learn to interact with the internet over TCP/IP (which is sadly non-differentiable) to access vital information needed to take over the world. That's a great example."}, {"id": 5, "title": "Conclusions", "content": "# Conclusions\n\nWe saw that Policy Gradients are a powerful, general algorithm and as an example we trained an ATARI Pong agent from raw pixels, from scratch, in 130 lines of Python. More generally the same algorithm can be used to train agents for arbitrary games and one day hopefully on many valuable real-world control problems. I wanted to add a few more notes in closing:\n\nOn advancing AI. We saw that the algorithm works through a brute-force search where you jitter around randomly at first and must accidentally stumble into rewarding situations at least once, and ideally often and repeatedly before the policy distribution shifts its parameters to repeat the responsible actions. We also saw that humans approach these problems very differently, in what feels more like rapid abstract model building - something we have barely even scratched the surface of in research (although many people are trying). Since these abstract models are very difficult (if not impossible) to explicitly annotate, this is also why there is so much interest recently in (unsupervised) generative models and program induction.\n\nOn use in complex robotics settings. The algorithm does not scale naively to settings where huge amounts of exploration are difficult to obtain. For instance, in robotic settings one might have a single (or few) robots, interacting with the world in real time. This prohibits naive applications of the algorithm as I presented it in this post. One related line of work intended to mitigate this problem is deterministic policy gradients - instead of requiring samples from a stochastic policy and encouraging the ones that get higher scores, the approach uses a deterministic policy and gets the gradient information directly from a second network (called a critic) that models the score function. This approach can in principle be much more efficient in settings with very high-dimensional actions where sampling actions provides poor coverage, but so far seems empirically slightly finicky to get working. Another related approach is to scale up robotics, as we're starting to see with Google's robot arm farm, or perhaps even Tesla's Model S + Autopilot.\n\nThere is also a line of work that tries to make the search process less hopeless by adding additional supervision. In many practical cases, for instance, one can obtain expert trajectories from a human. For example AlphaGo first uses supervised learning to predict human moves from expert Go games and the resulting human mimicking policy is later finetuned with policy gradients on the \"real\" objective of winning the game. In some cases one might have fewer expert trajectories (e.g. from robot teleoperation) and there are techniques for taking advantage of this data under the umbrella of apprenticeship learning. Finally, if no supervised data is provided by humans it can also be in some cases computed with expensive optimization techniques, e.g. by trajectory optimization in a known dynamics model (such as $F=m a$ in a physical simulator), or in cases where one learns an approximate local dynamics model (as seen in very promising framework of Guided Policy Search).\n\nOn using PG in practice. As a last note, l'd like to do something I wish I had done in my RNN blog post. I think I may have given the impression that RNNs are magic and automatically do arbitrary sequential problems. The truth is that getting these models to work can be tricky, requires care and expertise, and in many cases could also be an overkill, where simpler methods could get you $90 \\%+$ of the way there. The same goes for Policy Gradients. They are not automatic: You need a lot of samples, it trains forever, it is difficult to debug when it doesn't work. One should always try a BB gun before reaching for the Bazooka. In the case of Reinforcement Learning for example, one strong baseline that should always be tried first is the cross-entropy method (CEM), a simple stochastic hill-climbing \"guess and check\" approach inspired loosely by evolution. And if you insist on trying out Policy Gradients for your problem make sure you pay close attention to the tricks section in papers, start simple first, and use a variation of PG called TRPO, which almost always works better and more consistently than vanilla PG in practice. The core idea is to avoid parameter updates that change your policy too much, as enforced by a constraint on the KL divergence between the distributions predicted by the old and the new policy on a batch of data (instead of conjugate gradients the simplest instantiation of this idea could be implemented by doing a line search and checking the KL along the way).\n\nAnd that's it! I hope I gave you a sense of where we are with Reinforcement Learning, what the challenges are, and if you're eager to help advance RL I invite you to do so within our OpenAI Gym :) Until next time!"}, {"id": 6, "title": "Join the discussion...", "content": "# Join the discussion...\n\n## ## LOG IN WITH\n\n## ## OR SIGN UP WITH DISQUS (T)\n\n## Name\n\n## 19 Share\n\n## 2 years ago\n\nstill relevant\n\n$$\n4 \\quad 0 \\text { Reply } \\quad \\square\n$$\n\n## OzDuys\n5 months ago\n\"Since these abstract models are very difficult (if not impossible) to explicitly annotate, this is also why there is so much interest recently in (unsupervised) generative models and program induction.\" - Haha. Absolutely loving reading this sentence after the recent successes of LLMs!\n\n$$\n1 \\quad 0 \\text { Reply }\n$$\n\nfeng ding\na year ago\nI am a newcomer to the field of reinforcement learning, or rather, I am new to the field of artificial intelligence. Do you have any practical advice on how to better enter this field and conduct research effectively?\n\n## 10 Reply\n$\\square$ m\nmorty $\\rightarrow$ feng ding\n8 days ago\nDid you get any practical advice yet. I am too a newcomer to this field and in need of some advice\n\n$$\n0 \\quad 0 \\text { Reply }\n$$\n\n## Victor Leslie $\\rightarrow$ feng ding\na year ago\n## Are you doing this in a formal or exploratory capacity?\n\n$$\n0 \\quad 0 \\text { Reply }\n$$\n\nRe-wrote the code using PyTorch, if anyone interested: https://github.com/sukhitashvili/pong\n## 00 Reply"}, {"id": 7, "title": "ISO provider", "content": "# ISO provider\n\n7 months ago\nThis is a brilliant introduction to reinforcement learning. Your explanation makes a complex topic much more digestible and engaging. Achieve ISO Certification In Saudi Arabia to boost efficiency, ensure quality, and build trust with clients.\n\n$$\n0 \\quad 0 \\text { Reply }\n$$\n\n## Sebnem Ozturk\n\na year ago\nI tested the code recently. I trained over 48 hours but the agent didn't improve. I tried old versions of python and gym without any success. Did anybody encounter a similar situation. I really want to know what i am doing wrong.\n\n0\n## 0 Reply\n\n## D duckduckgoluck $\\rightarrow$ Sebnem Ozturk\na month ago\nthe code is working but it took like 30k episodes to have a $50 \\%$ chance to beat the AI opponent.\n\n0\n## Reply\n\n2009\n$\\rightarrow$ Sebnem Ozturk\n10 months ago\nFirstly, RGB is unnecessary; using a single band for each image will reduce both the search space and network complexity. Secondly, it's advisable to use a GPU, and implementing the code in PyTorch could be beneficial. Addressing these two factors could potentially reduce the processing time from 48 hours to less than 60 minutes.\n\n$$\n0 \\quad 0 \\text { Reply }\n$$\n\n## Testnwah\n\n4 years ago\n## Nice\n\n$$\n0 \\quad 0 \\text { Reply }\n$$\n\n## sarvagya Gupta\n\n6 years ago\nI want to know why has he used sequantial data from the memory to train the neural network? At some places, people taken random batches of data from the memory to train the network. What's the difference?\n\n$$\n0 \\quad 0 \\text { Reply }\n$$\n\nA great intuitive post about Policy Gradient. Thanks you!\n## 00 Reply\nshinybill $\\rightarrow$ 郭帅\n6 years ago\n## My chinese name is guoshuai,amazing!\n## 00 Reply\n$\\qquad$\n郭帅 $\\rightarrow$ shinybill\n6 years ago\n## I found that I had made a stupid grammar mistake! : (\n## 10 Reply\n\n## Gregg\n6 years ago\nThanks for writing this up Andrej. Very interesting!\n## 00 Reply\n\n## Sean Marshallsay\n8 years ago\nIf anyone's wondering where Richard Sutton's book went, it's on this site: http://incompleteideas.net/...\n## 00 Reply\n\n## Ricardo Decal\n8 years ago\n## Thanks for this post!\n## 00 Reply\n\n## Galtor\n8 years ago\n## Is deep q-learning equivalent to actor-critics based q-learning? which is the main difference?\n## 00 Reply\n\n## CHA\n8 years ago\nWould it be possible to develop a browser gaming bot in javascript for any game running in the browser? The whole screen or a certain area would deliver the input pixels and mouse click actions or areas and score areas could be defined as coordinates or maybe this could be implemented with sikuli http://www.sikuli.org/ since it already uses python.\n\n## 00 Reply\n\n> we are nowhere near humans in building abstract, rich representations of games that we can plan within and use for rapid learning. One day a computer will look at an array of pixels and notice a key, a door, and think to itself that it is probably a good idea to pick up the key and reach the door. For now there is nothing anywhere close to this, and trying to get there is an active area of research.\n\nSpeaking of which: \"Unifying Count-Based Exploration and Intrinsic Motivation\" https://arxiv.org/abs/1606.... Progress continues.\n\n0\n## 0 Reply\n\n## Karpathy Mod $\\rightarrow$ gwern\n9 years ago\nThis is a good paper looking at ways of patching an \"extremely silly random walk brownian motion no exploration whatsoever\" to \"somewhat silly exploration based on visitation frequency counts\". This is clever, sensible and easily applied especially in ATARI which is a fully"}], "pdf_images": {"pdf_path": "inbox/karpathy_rl.pdf", "total_pages": 18, "pages": [{"page_number": 1, "filename": "page-001.png", "thumb_filename": "page-001-thumb.png", "mobile_filename": "page-001-mobile.png", "mobile_thumb_filename": "page-001-mobile-thumb.png", "width": 1275, "height": 1650, "mobile_width": 2550, "mobile_height": 3300}, {"page_number": 2, "filename": "page-002.png", "thumb_filename": "page-002-thumb.png", "mobile_filename": "page-002-mobile.png", "mobile_thumb_filename": "page-002-mobile-thumb.png", "width": 1275, "height": 1650, "mobile_width": 2550, "mobile_height": 3300}, {"page_number": 3, "filename": "page-003.png", "thumb_filename": "page-003-thumb.png", "mobile_filename": "page-003-mobile.png", "mobile_thumb_filename": "page-003-mobile-thumb.png", "width": 1275, "height": 1650, "mobile_width": 2550, "mobile_height": 3300}, {"page_number": 4, "filename": "page-004.png", "thumb_filename": "page-004-thumb.png", "mobile_filename": "page-004-mobile.png", "mobile_thumb_filename": "page-004-mobile-thumb.png", "width": 1275, "height": 1650, "mobile_width": 2550, "mobile_height": 3300}, {"page_number": 5, "filename": "page-005.png", "thumb_filename": "page-005-thumb.png", "mobile_filename": "page-005-mobile.png", "mobile_thumb_filename": "page-005-mobile-thumb.png", "width": 1275, "height": 1650, "mobile_width": 2550, "mobile_height": 3300}, {"page_number": 6, "filename": "page-006.png", "thumb_filename": "page-006-thumb.png", "mobile_filename": "page-006-mobile.png", "mobile_thumb_filename": "page-006-mobile-thumb.png", "width": 1275, "height": 1650, "mobile_width": 2550, "mobile_height": 3300}, {"page_number": 7, "filename": "page-007.png", "thumb_filename": "page-007-thumb.png", "mobile_filename": "page-007-mobile.png", "mobile_thumb_filename": "page-007-mobile-thumb.png", "width": 1275, "height": 1650, "mobile_width": 2550, "mobile_height": 3300}, {"page_number": 8, "filename": "page-008.png", "thumb_filename": "page-008-thumb.png", "mobile_filename": "page-008-mobile.png", "mobile_thumb_filename": "page-008-mobile-thumb.png", "width": 1275, "height": 1650, "mobile_width": 2550, "mobile_height": 3300}, {"page_number": 9, "filename": "page-009.png", "thumb_filename": "page-009-thumb.png", "mobile_filename": "page-009-mobile.png", "mobile_thumb_filename": "page-009-mobile-thumb.png", "width": 1275, "height": 1650, "mobile_width": 2550, "mobile_height": 3300}, {"page_number": 10, "filename": "page-010.png", "thumb_filename": "page-010-thumb.png", "mobile_filename": "page-010-mobile.png", "mobile_thumb_filename": "page-010-mobile-thumb.png", "width": 1275, "height": 1650, "mobile_width": 2550, "mobile_height": 3300}, {"page_number": 11, "filename": "page-011.png", "thumb_filename": "page-011-thumb.png", "mobile_filename": "page-011-mobile.png", "mobile_thumb_filename": "page-011-mobile-thumb.png", "width": 1275, "height": 1650, "mobile_width": 2550, "mobile_height": 3300}, {"page_number": 12, "filename": "page-012.png", "thumb_filename": "page-012-thumb.png", "mobile_filename": "page-012-mobile.png", "mobile_thumb_filename": "page-012-mobile-thumb.png", "width": 1275, "height": 1650, "mobile_width": 2550, "mobile_height": 3300}, {"page_number": 13, "filename": "page-013.png", "thumb_filename": "page-013-thumb.png", "mobile_filename": "page-013-mobile.png", "mobile_thumb_filename": "page-013-mobile-thumb.png", "width": 1275, "height": 1650, "mobile_width": 2550, "mobile_height": 3300}, {"page_number": 14, "filename": "page-014.png", "thumb_filename": "page-014-thumb.png", "mobile_filename": "page-014-mobile.png", "mobile_thumb_filename": "page-014-mobile-thumb.png", "width": 1275, "height": 1650, "mobile_width": 2550, "mobile_height": 3300}, {"page_number": 15, "filename": "page-015.png", "thumb_filename": "page-015-thumb.png", "mobile_filename": "page-015-mobile.png", "mobile_thumb_filename": "page-015-mobile-thumb.png", "width": 1275, "height": 1650, "mobile_width": 2550, "mobile_height": 3300}, {"page_number": 16, "filename": "page-016.png", "thumb_filename": "page-016-thumb.png", "mobile_filename": "page-016-mobile.png", "mobile_thumb_filename": "page-016-mobile-thumb.png", "width": 1275, "height": 1650, "mobile_width": 2550, "mobile_height": 3300}, {"page_number": 17, "filename": "page-017.png", "thumb_filename": "page-017-thumb.png", "mobile_filename": "page-017-mobile.png", "mobile_thumb_filename": "page-017-mobile-thumb.png", "width": 1275, "height": 1650, "mobile_width": 2550, "mobile_height": 3300}, {"page_number": 18, "filename": "page-018.png", "thumb_filename": "page-018-thumb.png", "mobile_filename": "page-018-mobile.png", "mobile_thumb_filename": "page-018-mobile-thumb.png", "width": 1275, "height": 1650, "mobile_width": 2550, "mobile_height": 3300}]}, "metadata": {"model": "gpt-4o", "pdf_path": "inbox/karpathy_rl.pdf"}, "attribution": null};
        initializeColumnInterface();
    </script>
</body>
</html>